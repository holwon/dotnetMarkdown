# 异步概述

CPU 很强大, 可如磁盘之类的读写速度并跟不上 CPU 的运行速度. 如果 CPU 一直需要等待 IO 操作, 就会产生性能浪费

异步的方法可以由多线程来执行, 可多线程并不一定是异步

> 参考: [异步和多线程有什么区别](https://blog.csdn.net/qq_36936155/article/details/78991050)

## 多线程的优缺点

　　多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。

## 多线程的异步

虽然多线程的异步会比同步的方法快, 但是这个 "快的速度" 并不是线性增长的.
> [!NOTE]
>
> 多线程是需要有冷启动时间的, 因为 CLR 需要创建相应的线程池(ThreadPool), 来对 Thread 进行初始化.
> 而初始化每一个 Thread 也是需要时间的. 除此之外还有如 TCP 连接的时间等等.

1. 其在**运算量小**时, 5个线程的速度可以会比单线程快5倍. 可是运算量大时, 这个**速度差距**便会缩小, 其原因还是根据 CPU 的性能而体现. 计算机性能有极限.
2. **多线程并不一定比单线程快**. CPU 虽然强大, 可以进行时间切片来分配多线程. 但是, 线程的切换(时间切片)是需要进行**上下文切换**(加载环境,变量->计算->保存上下文)的, 其会带来**性能损耗**.

> [!WARNING]
>
> 多线程的**缺点**: 启动无序, 执行时间不确定, 结束无序
>
> ⚠️**一定不要通过等几毫秒的形式来控制启动/执行时间/结束**⚠️

> [!NOTE]
>
> 疑问: 为什么创建的多线程不按照**时间队列/代码顺序**?
>
> 因为现在 CPU 太快了, CPU本身就是多核心的, 运行起来是并发的(多个核心分配到**作业**就工作), 如果真要让核心按顺序进行 资源调度/CPU操作, 这样在本质上就是对 CPU 的浪费.

### 异步函数的顺序控制

> [!NOTE]
>
> 即使开发时通过延迟几毫秒来控制了线程的启动顺序, 即使可能很多时候都是正确控制了顺序, 但总有几次会失败的.
>
> 随着我们的程序运行数据量的累积或用户访问量的增加,
> 服务器性能的瓶颈, 会越来越明显.
>
> 🌟如果总是靠延迟来控制顺序, 程序的性能会很**低下**
>
> 我们应该使用 "*回调/状态等待/信号量*" 来控制顺序 详情: [异步控制](./C-Control-异步控制.md)

> 对于 Winform/WPF 的子线程是不可以直接操作 UI 的, 不过可以通过一些别的方式.

## Task

Thread 本身是一个前台线程, 在 Task 里面的 Thread 都是后台线程.
我们可以认为 Task 是基于 ThreadPool 封装的, 而不是 Thread
